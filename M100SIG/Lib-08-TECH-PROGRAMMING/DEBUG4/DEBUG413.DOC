





                        DEBUG for the TANDY Model 100/102
                           Version: 4.13  18/June/1990
                 Copyright: 1986,1987,1988,1989,1990 Adrian Ryan
                           P.O. Box 222, Carp, Ontario
                                 Canada, K0A-1L0

          DISCLAIMER

               This software  is provided  to you  on an "as-is" basis.
          You are entirely responsible for its  use.   The author makes
          no  warranties   as  to   the  suitability,  functioning,  or
          correctness, nor accepts any  liability  for  loss  or damage
          however caused.

               This is  not intended to convey the impression that this
          software  will  not  be  supported,  rather,  since  it  is a
          powerful tool  whose use is entirely outside of my control, I
          wish it to be clearly understood that since DEBUG can operate
          upon  any  memory  location,  any  I/O port, etc, it is quite
          possible for you to wipe out files and  lock up  the machine.
          If  all  else  fails,  turn  all the power OFF, including the
          memory power and start again.

          COPYRIGHT

               This product  has  been  developed  and  refined  over a
          number of years, and I am constantly honing and improving it.
          This version is distributed to you as shareware.  If you find
          this  program  to  be  useful  then please help to defray the
          costs by registering your copy with me.   I suggest  that $15
          would be  appropriate.   Even if you do not register, you are
          encouraged  to  distribute  this  program  and  documentation
          PROVIDING:-

               [1]  ALL the files are distributed;

               [2]  Neither the program nor the documentation files are
                    modified in any way;

               [3]  This copyright notice, and  that  appearing  in the
                    program are not removed or altered.












                                         Page - 1





               DEBUG  is  a  machine  language  program that contains a
          number of tools to  simplify the  production of  machine code
          for the  TRS 80  Model 100/102 computer systems.  The code is
          re-locatable so that it  can co-exist  with almost  any other
          machine language  program.   It is  compatible with the TANDY
          Disc/Video   Interface,   the   Travelling   Software  TS-DOS
          operating system  for the  TANDY Portable Disc Drive, as well
          as the FLOPPY.CO software also used by this hardware.

               The facilities provided in this program  will permit you
          to  examine  and  modify  the  contents  of memory locations,
          compare blocks of memory  for  similarities  and differences,
          move the  contents of  a block of memory from one location to
          another, as well  as  assemble  programs,  dis-assemble code,
          execute code  either at  full speed  or one  instruction at a
          time, and a number of other useful functions.

               Each function is executed  by means  of a  single letter
          command,  plus  in  some  cases,  a  set of data values.  The
          design of DEBUG is such as to follow the mnemonic conventions
          in general  usage for  this type  of program  as used on many
          machines, and in particular,  is deliberately  designed to be
          similar to  the same  named program used in the MS-DOS series
          of machines.   Consequently,  if  you  have  some familiarity
          with, for  example, MICROMON as used on the COMMODORE 64, DDT
          generally used in the  CP/M  environment,  or  DEBUG  as used
          under MS-DOS,  then you  will be  familiar with  the usage of
          DEBUG.

               In all cases it is  assumed  that  the  reader  has some
          familiarity  with   assembly  language   programming  on  the
          8080/8085 series of machines.  If this is not the  case, then
          consult one  of the many books available on this subject, for
          example:-

               MCS-85 User's Manual, INTEL Corp. 3065 Bowers Ave, Santa
               Clara, CA 95051. (408) 987-8080

               8080A-8085  Assembly  Language  Programming  by Lance A.
               Leventhal, Osborne/McGraw-Hill, 2600 Tenth  St. Berkley,
               CA. 94710. ISBN 0-931988-10-1

               8080/8085  Assembly  Language  Subroutines  by  Lance A.
               Leventhal, Winthrop  Saville,  Osborne/McGraw-Hill, 2600
               Tenth St. Berkley, CA 94710. ISBN 0-931988-58-6.








                                         Page - 2





          CONTENTS

               This package consists of the following files:-

          [1]  DBMAKE.DO  a  BASIC  program  to  re-generate  the  file
               DEBUG.CO from the data file DB413.DO

          [2]  DB413.DO ASCII hex data file for item [1]

          [3]  DBDOC.DO this document.

          [4]  DBCFG.DO a BASIC program to re-locate  the DEBUG.CO file
               to any desired address.

          INITIAL SETUP

               In  order  to  re-construct the machine language program
          DEBUG.CO and save it as a file you will need at least  21K of
          free  memory.    This  is  only  necessary the first time you
          perform this operation, DEBUG itself  is  only  4.7K.   Clear
          memory of all other programs, and load the files DB413.DO and
          DBMAKE.DO.  Enter BASIC and execute the command:-

               CLEAR 512,58073

          Now load and execute  the file  DBMAKE.DO.   The program will
          check  that  sufficient  memory exists to re-construct DEBUG,
          and will abort with a message if this  is not  the case.   If
          all is  OK, then  the program will prompt you for the name of
          the data file.  Enter the name you used, normally DB413.

               The program will then display the  address and  the data
          as  it  re-constructs  the  machine code from the hexadecimal
          data file.   At  the  end  of  the  process  the  checksum is
          compared.   If no  errors are  encountered the amount of free
          memory remaining will be checked, and if you  have sufficient
          then you  will be  prompted whether you wish to save DEBUG as
          a file.

               Once you have the machine code version of DEBUG, you can
          save it  to cassette  or disc,  and you  will not need to use
          either the DB413.DO or the DBMAKE.DO files again.

          CONFIGURATION

               DEBUG can be configured  to  run  at  almost  any memory
          location  with  the  aid  of  the  utility  package DBCFG.DO.
          Initially, DEBUG.CO is assembled  to  load  into  memory from
          address 58073 through to 62822, with an entry point at 58073.
          If you do not have any  other machine  language programs that
          use  this  address  space,  DEBUG  can  run at this location.
          However, if you have  additional  software,  for  example the

                                         Page - 3





          Disk Operating System for the TANDY DVI, or Floppy.CO, or the
          RAM resident version of TS-DOS for  the portable  disk drive,
          then DEBUG  must be  re-located to  avoid conflict with these
          programs.

               In order to perform  this  re-location,  load  the DBCFG
          program.   Enter BASIC  and clear  memory (save any important
          files first) with the command:-

               CLEAR 0,58073

          Then, if DEBUG.CO is not already saved as a RAM  memory file,
          load DEBUG with the command:-

               CLOADM "DEBUG" {Assumes DEBUG.CO is on cassette}

               The machine  will load the DEBUG.CO file and should show
          the following display:-

               Top: 58073
               End: 62822
               Exe: 58073

          Save the file with the command:-

               SAVEM "DEBUG" 58073,62822,58073

               DEBUG needs 4886 bytes  of memory  in order  to run, and
          thus the  highest address  at which  you can  load it is 4887
          bytes lower than the TOP address of any program with which it
          must co-exist.   Set  the HIMEM  pointer for this co-resident
          software, and load it into memory.  Now enter BASIC and enter
          the instruction:-

               PRINT HIMEM - 4887

               The value  printed is  the highest  address at which you
          can  load  DEBUG  in  order  to  co-exist  with  the existing
          software.    DBCFG  will  examine  the  directory looking for
          DEBUG.CO.  If it is missing, or if the wrong version of DEBUG
          is  found,  DBCFG  will  display  an error message and abort.
          Assuming that the  correct  version  is  found,  you  will be
          prompted with the current address information of DEBUG.CO and
          queried for a new starting address.  Enter the value that was
          calculated  earlier.    You  will  be  asked  if  you wish to
          proceed.

               If you answer anything other then 'Y' or 'y', DBCFG will
          exit without  making any  changes.  If you continue, then the
          display will blank for a few seconds, then the message:-

               Address Offset: xxxx

                                         Page - 4





          will be displayed, where  'xxxx' will  be a  rapidly changing
          number.    At  the  end  of the process, DEBUG will have been
          modified in its directory  file  slot  to  exist  at  the new
          target location.   Load  and execute as for any other machine
          language program.

               Note  that   the  re-location   process  is  reversible.
          DEBUG.CO can  be re-located  as many  times as  you wish.  In
          order for this to occur correctly,  it is  VITAL that neither
          DEBUG.CO nor  DBCFG.DO are  modified in  any way!  Failure to
          heed this warning will result in severe corruption  of DEBUG,
          with unpredictable results.

          DEBUG COMMAND SYNTAX

          [A]ssemble     addr1
          [B]reakpoint   [addr1]
          [C]alculate    arg1   [arg2]
          [D]isplay      addr1  [addr2]
          [E]nter        addr1  arglist
          [F]ill         addr1  addr2  num/char
          [G]o           addr1
          [H]ex to Dec   arg1   [arg2]
          [L]ength       [num]
          [M]ove         addr1  addr2  numbytes
          [P]rinter
          [Q]uit
          [R]egister     [arglist]
          [S]earch       addr1  addr2  arglist
          [U]nassemble   addr1  [addr2]
          [V]erify       addr1  addr2  numbytes
          [W]alk         addr1
          [X]pand Flags  [arglist]

          ASSEMBLE

          Syntax :  A addr1
          Example:  A C000

               This command  is a line oriented assembler for the 8085,
          which  will  start  the  assembly  at   addr1.  The  standard
          mnemonics are used, with a minor restriction.

               In order to minimise the amount of space occupied by the
          mnemonic op-code table, the  op-codes PUSH/POP  PSW have been
          changed to PUSH/POP AF.

               All numeric  data must be entered as HEXADECIMAL digits,
          and must be preceded by the $ symbol.  Leading  zeros are not




                                         Page - 5





                             DEBUG COMMAND REFERENCE

          required.   Note however,  that the  RST command operands are
          considered part of the op-code, and therefore are  entered as
          a single digit without the $ prefix.

          Thus, for example:-

               MVI  A,$6
               LXI  H,$1234
               JMP  $C000

          but:-

               RST  4

               A legal  statement can  consist of any number of leading
          spaces, a 2, 3, or  4  character  mnemonic  op-code,  a legal
          separator,  and  the  legal  operand  field  for  the  chosen
          mnemonic.  Legal separator characters are the tab,  comma and
          space symbols.

               Thus the following lines are all legal:-

          MVI  A     $FF
          MVI A,$FF
          MVI,A,$FF

          or any  combination of the above.  All lower case entries are
          converted to upper case prior to being processed.

               The command will terminate when a blank line is entered.
          Illegal mnemonics/operations  will cause  a beep, and will be
          ignored.

               When  the  ENTER  key  is  pressed,  if  the   line  was
          acceptable,  it  is  immediately  assembled  and entered into
          memory.  Then the dis-assembler routine will examine the code
          and display  exactly what  was entered so that you may verify
          that your intentions have been correctly interpreted.

          See GENERAL NOTE [8] for illegal op-code recognition.

          BREAKPOINT

          Syntax :  B [addr1]
          Example:  B C025

               This command will  set  or  clear  a  breakpoint  at the
          specified  address.    When  a breakpoint is encountered, the
          original code at  that  address  will  be  restored,  and the


                                         Page - 6





                             DEBUG COMMAND REFERENCE

          program will  halt and  display the dis-assembled code at the
          breakpoint, as well as the current register contents.

               If  the  address  specification  is  omitted,  then  the
          breakpoint will  be cleared  if it  was set, or if it was not
          set, the command will  be ignored.   Note  that the  WALK and
          QUIT  commands   will  restore  any  set  breakpoints  before
          executing.  Furthermore, breakpoints may only be set  in RAM,
          and  if  an  attempt  is  made  to specify a ROM address, the
          routine will beep and return to the command line.

          CALCULATE

          Syntax :  C arg1 [arg2]
          Example:  C 0034 FE11

               This  command,  if  followed  by  two  parameters,  will
          calculate their sum and difference, if only a single argument
          is specified, the ASCII 2-byte equivalent  will be displayed,
          along with  the binary and decimal equivalents.  See also the
          HEX command.

          DISPLAY

          Syntax :  D addr1 [addr2]
          Example:  D C000 C123

               This command displays the contents of  memory from addr1
          to addr2  in HEX  and ASCII,  either on the printer or on the
          current video screen.  If only one argument is supplied, then
          the  8  bytes  at  that  address  will  be displayed, and the
          program will wait.  If the cursor up key is pressed, the next
          8 bytes  of memory  will be displayed, if the cursor down key
          is pressed, the previous 8  bytes  will  be  displayed.   The
          ENTER key terminates the command.

               If both address arguments are given, a continuous memory
          dump occurs, in ascending  address  order,  on  the currently
          selected output device. (Screen or Printer)  If the device is
          the screen, the display will pause after a  certain number of
          lines have  been displayed,  and will continue when the SPACE
          bar is pressed.  The printer  is assumed  to be  a continuous
          display device, and no pause is made.

               Whilst  a  continuous  dump  is in progress, hitting any
          alphanumeric  key   will  temporarily   suspend  the  output.
          Hitting the  SPACE bar  will cause  the dump to resume.  This
          facility is applicable to both screen and printer.  See the P
          and L commands.


                                         Page - 7





                             DEBUG COMMAND REFERENCE

          ENTER

          Syntax :  E addr1 arglist
          Example:  E C000 AB F0 'abcdef' 0D 0A

               This   command   will   permit  entering  HEX  or  ASCII
          characters into memory  from  addr1.    To  specify  that the
          characters  are  ASCII,  the  string  must be enclosed in the
          single quote character, (').  The arglist may  be composed of
          any combination  of HEX  digits or delimited ASCII strings up
          to a maximum composite string length of 64  characters.  Note
          that  the  hex  digits  are  expected to evaluate to an 8 bit
          quantity, and all arguments must be delimited with  spaces or
          tabs.

          FILL

          Syntax :  F addr1 addr2 num/char
          Example:  F C000 CFFF E0

               This command  will fill  the memory  from addr1 to addr2
          with the value of num, or the ASCII character char.  An ASCII
          character is  specified by preceding it with the single quote
          character, (').

          GO

          Syntax :  G addr1
          Example:  G C000

               The code pointed to by addr1  will be  executed by means
          of  a  CALL  instruction,  using  the current pseudo-register
          contents.  To ensure that control is returned  to DEBUG, your
          code must  end with  a RET instruction, or a conditional RET.
          When control returns, the  register  contents  are displayed,
          and  DEBUG  will  restore  the  stack  pointer to its default
          setting.

          See GENERAL NOTE [4] regarding use of stack.

          DECIMAL to HEX Conversion

          Syntax :  H arg1 [arg2]
          Example:  H 65535

               This command, if followed by a  single decimal argument,
          will convert  it to  HEX and display the HEX, DECIMAL, ASCII,
          and BINARY equivalents.  If the command is  followed with two
          arguments,  the   HEXADECIMAL  sum  and  difference  will  be
          displayed.  See also the CALCULATE command.

                                         Page - 8





                             DEBUG COMMAND REFERENCE

          LENGTH

          Syntax :  L [num]
          Example:  L 5

               This command sets the  number  of  lines  on  the active
          display  screen.    In  the  case  of  the  LCD,  the maximum
          practical number is 8, although the  command will  accept all
          values from  1 to  FF.   The effect  is to  pause the current
          display after num lines  have been  displayed.   Pressing the
          SPACE key  will continue the display for a further num lines.
          This command has no effect on the printer.   If  the optional
          argument is omitted, the current length setting is displayed.

          MOVE

          Syntax :  M addr1 addr2 numbytes
          Example:  M C000 E000 1F4

               The memory contents pointed to by addr1 will be moved to
          addr2  for  the  number  of  bytes   specified  by  numbytes.
          Overlapping source and destinations are permitted.

          PRINTER

          Syntax :  P

               This command  will alternately  toggle the output of the
          D, S, U and V commands between the current display device and
          the printer.   If  a printer is not connected or is busy, the
          program will wait indefinitely.  The L command  has no effect
          on the length of the printer output.

          QUIT

          Syntax :  Q

               This command will quit DEBUG and return you to the MENU,
          restoring any set breakpoints in the process.

          REGISTER

          Syntax :  R [arglist]
          Example:  R E3 FFFF 1234 A000

               This command displays  the  pseudo-register  contents if
          there is  no arglist, or, if the optional arglist is present,
          will set the pseudo-registers  to  the  values  specified and
          then display the contents.


                                         Page - 9





                             DEBUG COMMAND REFERENCE

               Registers are specified in the order:-

               AF BC DE HL

               A comma  must be used to skip over a register. Thus, for
          example, if you wish to set  the  HL  register  pair  to C000
          without disturbing the other registers the command would be:-

               R ,,,C000

               Should  you  wish  to  set  only  the  AF  register, for
          example, then the command:-

               R E800

          would set  the A register to the value E8, and the F register
          to 00, leaving the other register settings undisturbed.

          See GENERAL NOTE [9] regarding illegal flags.

          SEARCH

          Syntax :  S addr1 addr2 string
          Example:  S C000 E000 'abcdef' AD BC 0

               This command will  search  memory  from  addr1  to addr2
          examining  each  byte  trying  to  match  the string of ASCII
          characters or HEX digits specified in the third argument.  In
          the example  given, the  search will be from C000 to E000 for
          the text string abcdef followed by the HEX digits AD BC 00.

               To specify that the characters are  ASCII, they  must be
          enclosed by  the single quote (') delimiter.  Both delimiters
          must be  present!   Any other  characters will  be treated as
          pairs of HEX digits.

               If an  illegal character  is specified, the command line
          will be ignored.  The search will find all occurrences of the
          target string,  and the addresses displayed correspond to the
          location of the  first  character.    Only  the  command line
          prompt will  be displayed  if the target string is not found.
          Note that for a search operation  to be  successful, an exact
          match  must  occur.    Upper  and  lower  case  letters  in a
          delimited ASCII string do  not  match.    The  maximum search
          string length is 64 bytes.

               The  output  of  this  command may be re-directed to the
          printer with the 'P' command,  and  can  be  suspended during
          execution by  hitting any  alpha-numeric key.   Output can be


                                         Page - 10





                             DEBUG COMMAND REFERENCE

          resumed by hitting the  SPACE  bar.    The  execution  can be
          aborted by hitting the ENTER key.

          UN-ASSEMBLE

          Syntax :  U addr1 [addr2]
          Example:  U C000 C123

               This command  will dis-assemble  the code  from addr1 to
          addr2 and  display the  results on  the current  screen.  The
          mnemonics  are  consistent  with  those  used by the ASSEMBLE
          command.

               If the second argument is omitted, then only one line of
          code will  be unassembled.   The  program will  then wait for
          either the cursor up key to be pressed, which will  cause the
          next  line  to  be  displayed,  or  the ENTER key, which will
          terminate the unassembly.

               The  same  SUSPEND,  LENGTH,  and  ABORT  facilities are
          available as for the D, S, and V commands.

          See GENERAL NOTE [8] for illegal op-code recognition.

          VERIFY

          Syntax :  V addr1 addr2 numbytes
          Example:  V C000 D000 1000

               This command will compare the contents of memory between
          addr1 and addr1 + numbytes with  the contents  of memory from
          addr2 to addr2 + numbytes.  If no differences are found, then
          only the command line prompt will be returned.

               If a  difference  is  found  the  address  of  the first
          section  and  the  contents  as  well  as  the  corresponding
          address/contents of the  second  section  will  be displayed.
          This command  will also  allow output  to be  diverted to the
          printer, and will pause at the  end of  the currently defined
          screen, as  well as  responding to the ENTER key to abort the
          output.










                                         Page - 11





                             DEBUG COMMAND REFERENCE

          WALK

          Syntax :  W addr1
          Example:  W C000

               This command permits single  stepping the  code starting
          at  addr1.    Prior  to executing the next instruction, DEBUG
          will display the current  register contents  and dis-assemble
          the instruction.

          WALK has four sub-commands:-

          Single Step

               Pressing  the  cursor  up-arrow  key will cause DEBUG to
          execute the currently displayed instruction.   At the  end of
          the execution,  the new  register contents will be displayed,
          and the next instruction dis-assembled.

          Execute Sub-Routine

               Pressing the 'X' key  will allow  you to  execute a sub-
          routine CALL/RST  at full  speed and return control to DEBUG.
          This facility saves you having to single step through code in
          a sub-routine  that is already well behaved, for example, the
          ROM routines.  Note that DEBUG will check to verify  that the
          code byte  is actually  that of  a CALL, RST or a conditional
          CALL.  All other op-codes are ignored.

          Execute Code

               Pressing  the  'G'  key  will  cause  DEBUG  to transfer
          control to  the code  at the  current address.  It is exactly
          the same  as exiting  from WALK  and entering  the GO command
          using the  current address.  As with the GO command, in order
          for control to be returned to DEBUG, your code must  end with
          a RET or conditional RET op-code.

          Quit

               Depressing the ENTER key will terminate the WALK command
          without executing the currently  displayed code.   DEBUG will
          restore the default stack pointer setting on exit.

          Note that both RAM and ROM code can be walked.

          See GENERAL NOTE [8] for illegal op-code recognition.




                                         Page - 12





                             DEBUG COMMAND REFERENCE

          XPAND FLAGS

          Syntax :  X [arglist]
          Example:  X E3

               This  command  will  display  the  current flag register
          contents in  an expanded  form.   If the  command is followed
          with an argument then the flag settings corresponding to this
          HEX byte value will be displayed.  The existing flag register
          settings will not be altered.  See REGISTER.

          See GENERAL NOTE [9] regarding illegal flags.

          GENERAL NOTES

          [1]  Numeric Argument Evaluation

               All numeric  arguments are  evaluated as  an unsigned 16
          bit integer.  If an overflow is detected,  the returned value
          is  zero,  and  an  error  occurs.    All  arguments  must be
          de-limited with spaces or tabs.

          [2]  Multiple Commands

               Multiple commands may be combined on the same  line. For
          example, to  set the  registers to  a particular value and to
          execute the code at a certain address the command line:-

               R FFE3 F123 1234 FFFF:G C000

          can be executed.  The  maximum  command  line  length  is 254
          characters,  and  is  stored  in the input buffer starting at
          $F685.

               Each  command  must  be  separated  by   the  colon  (:)
          character,  and  spaces  are  ignored  except  when part of a
          delimited ASCII string.    When  a  sequence  of  commands is
          given, if  DEBUG detects any errors whilst either parsing the
          command string, or attempting to execute the command, then it
          will abort  without executing  any following  commands.  If a
          major error is discovered,  then DEBUG  will complain  with a
          two-tone beep, whilst if a minor error was discovered, only a
          single tone  beep will  occur.   A major  error, for example,
          would  be  attempting  to  execute  a  command  that  is  not
          implemented.  A minor error would be the  presence of invalid
          characters in an argument, or an illegal address.

               Note that  the 'A',  'G' and 'W' commands are considered
          to be self-terminating, that  is,  they  should  be  the last
          command on a multiple command line.

                                         Page - 13





                             DEBUG COMMAND REFERENCE

          [3]  Case/Range Sensitivity

               Commands may  be entered  in upper  or lower  case.  All
          commands and command  line  HEX  arguments  are  converted to
          uppercase internally before processing.

               For  any   commands  that  can  have  an  address  range
          specification, note that it is immaterial in which  order the
          address references  are given.   For the D and U commands the
          range will be from the lowest to the  highest address, whilst
          the F, S, and V commands will always perform their tasks from
          the highest location downward.

          [4]  DEBUG Stack

               DEBUG  maintains  its   own   stack,   and   is  located
          immediately in  front of  the main code.  Since the code that
          is being debugged may mutilate the stack, the  actual initial
          stack pointer  setting is  32 bytes lower than the top of the
          stack, thus your code can mis-manage  the stack  for at least
          16  pops  too  many  before  any  corruption of DEBUG occurs.
          Every time either the  WALK  or  the  GO  commands terminate,
          after  saving  the  current  register contents in the pseudo-
          registers, the  stack  pointer  is  restored  to  its initial
          setting 32 bytes lower than the end of the stack space.

               If the  code that  you are  examining uses its own local
          stack, then  prior to  using the  GO command  you must ensure
          that the  return address  to DEBUG is preserved at the top of
          the new local stack.

          A section of code thus:-

               SHLD TEMP      ;Save current contents of HL
               POP  H         ;Recover return address to DEBUG
               SHLD RETADDR   ;Save return address
               LHLD TEMP      ;Restore old contents of HL

               {your code section goes here}

               SHLD TEMP      ;Save current contents of HL
               LHLD RETADDR   ;Recover DEBUG return address
               PUSH H         ;and put on top of stack.
               LHLD TEMP      ;Recover old HL contents,
               RET            ;and return to DEBUG.

          will ensure that you will return  to DEBUG.   Note  that only
          the  'G'  command  suffers  from  this  restriction,  the 'W'
          command is not affected  by any  local user  change of stack,


                                         Page - 14





                             DEBUG COMMAND REFERENCE

          except insofar  as the  user stack  must have  enough room to
          accommodate  DEBUG's  requirements.    Typically,  you should
          allow at  least 72  bytes for DEBUG, to avoid any stack over-
          run problem.  Note also that on return  from a  'W' or  a 'G'
          command DEBUG  will restore  the original  default stack that
          was used on entry to the program.

          [5]  Pseudo-Register Contents

               The contents  of the  pseudo-PC are  only updated during
          the WALK command, and when a breakpoint is encountered.  This
          register is  not  restored  to  the  machine  when  a GO/WALK
          command  is  executed,  for  obvious reasons.  Thus the value
          displayed in this register represents the  place in  the code
          at  which  either  the  WALK  was  terminated,  or at which a
          breakpoint was encountered.

               The Pseudo-SP  register  correctly  reflects  either the
          current contents of the SP register during a WALK or the last
          contents of the SP register prior to exiting  from either the
          'W' or 'G' commands.

          [6]  Cautions using the E/F Commands

               Exercise  caution  when  using  the ENTER/FILL commands.
          Even if DEBUG is  entered from  the main  menu, the operating
          system  maintains   a  stack  somewhere  in  memory,  and  an
          inadvertent alteration of this  memory  with  either  the E/F
          commands will  cause unpredictable  results.  In general, the
          computer  will  execute  a  cold  start  if  you accidentally
          overwrite a vital location.

          [7]  ROM/RAM Usage

               DEBUG makes  considerable use  of the Model 100 internal
          ROM  routines,  both  the   documented   calls   and  various
          undocumented routines.   The  code has been tested on a Model
          100 using the TANDY  DVI, with  no problems,  as well  as the
          Model 102.

               DEBUG  requires  137  bytes  of code space above the END
          address for  internal  buffers  and  uninitialised variables.
          When  re-locating  DEBUG  make  sure that the program you are
          debugging does  not attempt  to use  this space.   Follow the
          instructions given at the start of this document.






                                         Page - 15





                             DEBUG COMMAND REFERENCE

          [8]  Illegal Op-Code Recognition and Usage

               This  revision  of  DEBUG  now  recognises 9 illegal op-
          codes:-

          $08/DSUB B, $10/RHR, $18/RDL, $28/DMOV H,$nn   $38/DMOV S,$nn
          $D9/SHLX, $DD/JND $nnnn, $ED/LHLX, $FD/JD $nnnn.

               The  code  represented  by  HEX $CB is still regarded as
          illegal since it is useless on  an M100.   Note  however that
          these codes will only execute correctly if your 80C85 behaves
          like most others.  You must test these codes yourself on your
          machine.    The  ASSEMBLE/DIS-ASSEMBLE and WALK routines will
          recognise these codes and act appropriately.

               DEBUG itself makes no  use  of  these  illegal op-codes.
          However, it is obvious that some commercial software does use
          them, and even Microsoft uses them in the  ROM, hence despite
          my inherent  dislike and distrust of these "features", I felt
          obligated to include them in this tool.

          $08  DSUB B         [HL] = [HL] - [BC]
          $10  RHR            [HL] = [HL->] HL arithmetic right shift
          $18  RDL            Rotate DE left through Carry
          $28  DMOV H,$nn     [DE] = [HL] + $nn (unsigned)
          $38  DMOV S,$nn     [DE] = [SP] + $nn (unsigned)
          $CB  ???            Invalid. CALL $0040 if V flag set
          $D9  SHLX           Store [HL] at address pointed to by [DE]
          $DD  JND  $nnnn     Jump to $nnnn if flag bit 5 is clear
          $ED  LHLX           Load [HL] from address pointed to by [DE]
          $FD  JD   $nnnn     Jump to $nnnn if flag bit 5 is set

          [9]  Illegal Flags

               In this version of DEBUG the  register display  will now
          reflect the state of the two "unmarked" flag bits.  To remind
          you that they are  not "legal",  they are  displayed in lower
          case, thus a typical flag register display will be:-

               SZdA PvC
               10110101

          where the  'v' flag,  bit 1, is a conventional overflow flag,
          that is, it is set when the carry into the sign bit  does not
          equal  the  carry  out.    It signifies that the result of an
          operation on two signed  bytes was  too big  to fit  into one
          signed byte.   The  'd' flag, bit 5, is a "true" sign bit. It
          is what would be in bit 8 if the CPU were doing  9 bit signed
          arithmetic.


                                         Page - 16





                                 DEBUG TUTORIAL

               This  section  is  devoted  to  a  demonstration  of the
          features and facilities of the DEBUG  program.   It is mainly
          of  interest  to  the  relative newcomer to assembly language
          programming who is seeking an easy way to explore the uses of
          this  tool.    It  assumes  that  you  are  familiar with the
          instruction set of the  8080/8085 processor,  as well  as the
          elementary   concepts    of   looping,   branching,   calling
          sub-routines, as  well as  moving data  between registers and
          memory.

               To begin,  ensure that  DEBUG is loaded into memory, and
          exists in the directory of  your  machine  as  a  file called
          DEBUG.CO.  Moreover, in order that the later examples provide
          the displays as described in this  section, use  DEBUG at its
          base  address  location  as  supplied.    From the main menu,
          select DEBUG.CO and press  the ENTER  key.   The title screen
          should display  the program title, authors name, and revision
          number and date, and a ? prompt.

               To refresh your memory, recall that the 8085 is provided
          with a number of registers thus:-

                                 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                 ³     PC      ³
                                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                                 ³     SP      ³
                                 ÃÄÄÄÄÄÄÂÄÄÄÄÄÄ´
                                 ³  H   ³   L  ³
                                 ÃÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                                 ³  D   ³   E  ³
                                 ÃÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                                 ³  B   ³   C  ³
                                 ÃÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                                 ³  A   ³   F  ³
                                 ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÙ

                                8085 Register Set

               The AF  register pair  consists of the A register, often
          called the Accumulator, and the F register, often  called the
          Flag  register.    (The  INTEL  documentation  refers to this
          latter register as the Processor Status  Word, PSW)   Both of
          these registers are 8 bits in length.  The B, C, D, E, H, and
          L  registers  are  general  purpose  8-bit   registers.    In
          addition, the BC, DE, and HL register pairs can be treated as
          16-bit general purpose registers.

               The first example of the use of DEBUG  shows how  we can
          preset these  registers to  various values using the Register
          command.

                                         Page - 17





                                 DEBUG TUTORIAL

               Enter the letter R and press the ENTER  key, the machine
          should display:-

                PC   AF   BC   DE   HL   SP
               0000 0000 0000 0000 0000 E2B9

               This  displays  the  current  contents of the registers.
          The PC register represents  the machine  Program Counter, and
          will only  be updated  after a  'G' or  during a 'W' command.
          The SP register indicates the Stack Pointer, and  is shown as
          pointing to  a location  within the  DEBUG program work area.
          When a 'G' or 'W' command is executed the AF, BC, DE,  and HL
          registers will  be set to the values indicated, in this case,
          all will be set to 0000.

               Now let us set the  BC  register  to  contain  the value
          1234.     (Throughout  this   section,  all  numbers  are  in
          HEXADECIMAL unless otherwise identified.)    Since  we cannot
          explicitly alter the contents of the PC register, and we wish
          to skip  over the  AF register  pair, we  do so  by putting a
          comma in  the command  to indicate to DEBUG that the register
          is to be skipped.  Thus, when we execute the command:-

               R,1234

          we will obtain the display:-

                PC   AF   BC   DE   HL   SP
               0000 0000 1234 0000 0000 E2B9

          This shows that we set the  register to  the value indicated.
          Try entering the command:-

               R FF00

          The display should be:-

                PC   AF   BC   DE   HL   SP
               0000 FF00 1234 0000 0000 E2B9

          Now try  setting the  HL register to 4321 and the BC register
          to FFFF.  You will need  a comma  to skip  over the  AF pair,
          then the  value FFFF  for the  BC pair, another comma to skip
          the DE pair, and finally the value 4321 for the HL pair.  Try
          entering  several  spaces  between  the commas and values and
          observe the result, thus:-

               R     ,   FFFF     ,  4321



                                         Page - 18





                                 DEBUG TUTORIAL

          The display should now show:-

                PC   AF   BC   DE   HL   SP
               0000 FF00 FFFF 0000 4321 E2B9

          Try for yourself setting  all  the  registers  back  to their
          initial  values.    Notice  that  DEBUG  ignored the spurious
          spaces between the various parameters we entered.  Similarly,
          repeat the experiment by using lower case letters and observe
          that DEBUG is case insensitive.   As we  shall see,  the only
          time that  a distinction is made between upper and lower case
          is when the letter(s)  are  part  of  a  quoted  or delimited
          string.

               Having  seen  the  use  of  the  'R' command, let us now
          examine the contents of memory.   For this  we shall  need to
          master the use of the Display command.  Enter the command:-

               D 7FA4

          the display should be:-

               7FA4 54 52 53 2D 38 30 20 4D TRS-80 M

          Notice first  of all that the '?' prompt has disappeared, and
          has been replaced with the blinking cursor.   This means that
          DEBUG  is  waiting  for  a  sub-command  to continue or quit.
          There are a number of commands that behave in this  way.  All
          the commands  that can have a range of address' will wait for
          further instructions if only a single address is given.

               In this case, first field of  data is  the address 7FA4,
          the  address  at  which  the  data  dump started.  The next 8
          fields represents the  HEX  contents  of  the  address' 7FA4,
          7FA5, 7FA6, 7FA7, 7FA8, 7FA9, 7FAA, and 7FAB.  The right hand
          field displays the ASCII equivalents of the HEX  contents, in
          this case  the letters  T, R,  S, -,  8, 0, space, and M.  In
          fact, this is the  place  in  the  Model  100  ROM  where the
          copyright  message  is  located.    By pressing the cursor UP
          ARROW key you can display the contents of the next 8 bytes of
          memory.  The display should show:-

               7FA4 54 52 53 2D 38 30 20 4D TRS-80 M
               7FAC 6F 64 65 6C 20 31 30 30 odel 100

               By pressing  the UP ARROW again the contents of the next
          8 bytes can be displayed.    Similarly,  pressing  the cursor
          DOWN  ARROW  the  contents  of  the  previous  8 bytes can be
          displayed.  If the contents of the memory  is not  text, then
          the  ASCII  field  of  the  dump,  as  the right hand side is

                                         Page - 19





                                 DEBUG TUTORIAL

          called, will display the  graphic symbol  that corresponds to
          the data  at that  memory location, or a blank if there is no
          symbol that can be displayed.  To exit  this mode,  press the
          ENTER key.   Observe the return of the '?' prompt, signifying
          that you are returned to the command mode of DEBUG.

               Now let us display these same memory locations, but this
          time using a range of address values.  Enter the command:-

               D 7FA4 7FAD

          The display should be:-

               7FA4 54 52 53 2D 38 30 20 4D TRS-80 M
               7FAC 6F 64 65 6C 20 31 30 30 odel 100

          Notice  that  we  have  been  returned  to  the  command mode
          immediately after  the  command  executed.    Also  note that
          although we specified the range of address as being from 7FA4
          to 7FAD, DEBUG has  displayed  the  nearest  range  that will
          include the  specified address.  If the higher address is not
          exactly on an 8  byte boundary,  then DEBUG  will display the
          complete 8  bytes in  which it  is located.  Try entering the
          command:-

               D 7FAD 7FA4

          You should have obtained exactly the same display  as before.
          This shows  that for a range of address' DEBUG is insensitive
          to the order in which they are entered.   The  'D' command is
          generally  the   first  command   that  you  would  try  when
          attempting to "unpick" some strange code.  You would look for
          the display messages and note the starting address as well as
          the string termination bytes.  Knowing this data you can then
          proceed to examine the code in rather more detail.

               Now  let  us  examine  the  Length  command.   Enter the
          command:-

               L

          DEBUG should respond with the message:-

               Screen length: 7 lines

          In this case, this means that for any command that can take a
          range of  address, the  display will  be 7  lines, then DEBUG
          will pause with the message:-

               Press SPACE to continue...

                                         Page - 20





                                 DEBUG TUTORIAL

          Pressing the SPACE bar  will cause  a further  7 lines  to be
          displayed, and  then DEBUG will pause again.  The display can
          be terminated by pressing the ENTER key whilst the display is
          in progress.  Try entering the 'D' command with a large range
          of address, for example:-

               D 1000 2000

          and observe the results.  When the display  is scrolling, hit
          an  alpha  key  or  the  SPACE  bar.  Notice that the display
          immediately paused with the previous message.  This is useful
          if  you  wish  to  temporarily  suspend the output whilst you
          examine the display.   Press  the  space  bar  to  resume the
          display, and  press the  ENTER key  to abort.   Now enter the
          command:-

               L 5

          DEBUG should respond with the message:-

               Screen length: 5 lines

          By  this  means  it  is  possible  to  alter  the  amount  of
          information that  is presented  during a  lengthy display, to
          that which best suits your immediate  needs.   If you attempt
          to set  the length  parameter to 0, DEBUG will merely display
          the current setting.  The maximum value is FF, or  255 lines.
          Now enter the commands:-

               L 5:L 6:L 7

          DEBUG should respond:-

               Screen length: 5 lines
               Screen length: 6 lines
               Screen length: 7 lines

          This  demonstrates  that  DEBUG  can  execute  a  sequence of
          commands, provided  that  they  are  separated  with  the ':'
          symbol.   Note however that the 'A', 'G' and 'W' commands are
          self-terminating, that is, they  should be  the LAST command,
          because DEBUG  will ignore any command sequence entered after
          one of these commands if it  is entered  on the  same command
          line.

               Now let us use the Move command to transfer the contents
          of the ROM memory to a place in RAM.  It is  assumed for this
          tutorial that only DEBUG.CO is present in memory.  If this is
          not so,  then the  following operations  could destroy files.


                                         Page - 21





                                 DEBUG TUTORIAL

          For this  reason, you  may wish to quit this session and save
          the files and then  erase them  before continuing.   The Quit
          command is simply the letter 'Q'

               To move the memory contents, enter the command:-

               M 7FA4 C000 30

          DEBUG should respond with the message:-

                Done

          Now examine the memory from C000 to C030 with the command:-

               D C000 C02F

          The display should be:-

               C000 54 52 53 2D 38 30 20 4D TRS-80 M
               C008 6F 64 65 6C 20 31 30 30 odel 100
               C010 20 53 6F 66 74 77 61 72  Softwar
               C018 65 0D 0A 43 6F 70 72 2E e  Copr.
               C020 20 31 39 38 33 20 4D 69  1983 Mi
               C028 63 72 6F 73 6F 66 74 0D crosoft

               What we  did was  to copy  the contents  of address 7FA4
          through 7FD3 to address  C000 to  C02F.   You may  be asking,
          "Why, when  we specified  30 bytes  to copy,  did the address
          stop at 7FD3 rather than 7FD4?"  This is because we specified
          that we  must copy  30 hex,  or 48  decimal bytes starting at
          7FA4.  Thus the last  address  will  be  7FD3.    Display the
          memory contents  from 7FA4 to 7FD4 and count out the 48 bytes
          starting at 7FA4.   You  will  find  that  the  last  byte is
          address  7FD3.    It  is  most  important to remember that we
          NUMBER from 0, 1, 2, 3  etc, but  we COUNT  from 1,  2, 3 ...
          etc.

               The  move  command  is  useful  for  moving fairly large
          blocks of data from one place in memory to another.

               How can we be sure that the contents  of memory  at C000
          is  the  same  as  that  at  7FA4?   This is where the Verify
          command comes in useful.  Enter the command:-

               V 7FA4 C000 2F

          DEBUG will respond with only the '?' prompt.  This is because
          there were  no differences  found.   Why did we use the value
          2F instead of 30?  This  is again  because of  the difference
          in  the  way  we  NUMBER  and  the  way we COUNT.  The verify

                                         Page - 22





                                 DEBUG TUTORIAL

          command adds the last argument to the first  two arguments in
          order to arrive at the last address to compare.

               To demonstrate  what happens when a difference is found,
          let us alter the byte at address C010 with the Enter command.
          Enter the following command:-

               E C010 0

          DEBUG responds with the message:-

                Done

          Now repeat the previous command:-

               V 7FA4 C000 2F

          DEBUG will display:-

               7FB4 20 C010 00

          thus  showing  that  at  7FB4  the contents are 20 but at the
          corresponding address  of  C010  there  is  00.    The verify
          command will  list all  the differences between two blocks of
          memory from the highest address downward.

               Suppose we now wish to simply Fill memory  with a value.
          We would  use the F command.  Let us now use the F command to
          fill the memory we  just used  with zero's,  and at  the same
          time use  the display  command to verify that we did do as we
          wished.  Enter the commands:-

               F C000 C02F 0:D C000 C02F

          Did you obtain the display:-

                Done
               C000 00 00 00 00 00 00 00 00
               C008 00 00 00 00 00 00 00 00
               C010 00 00 00 00 00 00 00 00
               C018 00 00 00 00 00 00 00 00
               C020 00 00 00 00 00 00 00 00
               C028 00 00 00 00 00 00 00 00

               This command permits you  to fill  memory with  either a
          HEX byte, or an ASCII character.  For example, the command:-

               F C000 C006 '#:D C000 C006



                                         Page - 23





                                 DEBUG TUTORIAL

          will produce the display:-

                Done
               C000 23 23 23 23 23 23 23 00 #######

               The 'F'  command is  useful for  clearing large areas of
          memory or otherwise setting  a block  of memory  to a defined
          state.    Be  careful,  however, that you do not accidentally
          over write the reserved RAM of the system  or you  will cause
          the operating system to crash.

               Sometimes it is necessary to enter specific sequences of
          data into memory, for example, a text message.  For  this job
          we can use the Enter command.  Enter the commands:-

               E C000 'ABCDEF':D C000 C007

          DEBUG should respond:-

                Done
               C000 41 42 43 44 45 46 23 00 ABCDEF#

          The enter command can also use HEX arguments thus:-

               E C000 0 1 2 3 4 5:D C000 C007

          to produce the result:-

                Done
               C000 00 01 02 03 04 05 23 00       #

          In fact,  any sequence of HEX digit pairs and delimited ASCII
          strings up to a maximum composite length of  64 bytes  can be
          entered in this way.  Experiment with various combinations to
          demonstrate the use of this feature.

               Many times we need to perform address calculations.  The
          Calculate  command  will  allow  us this facility.  Enter the
          command:-

               C 7FA4 2F

          DEBUG will display:-

               7FA4 002F +7FD3 -7F75

          to indicate that the SUM (+) of these numbers is 7FD3, whilst
          the DIFFERENCE  (-) is  7F75.  We can also obtain the DECIMAL
          and ASCII equivalents of a 16  bit  number  by  using  only a
          single argument thus:-

                                         Page - 24





                                 DEBUG TUTORIAL

               C 4142

          DEBUG will display:-

               4142 16706 AB 0100 0001 0100 0010

          This  shows  that  the  HEX  NUMBER 4142 is equivalent to the
          DECIMAL  NUMBER  16706,  that  the  HEX  DIGIT  pairs  41  42
          represent  the  ASCII  characters  'A'  and 'B', and that the
          binary  representation  consists  of  4  nibbles  having  the
          pattern:- 0100 0001 0100 0010

               Sometimes we need to convert from decimal to hex.  The H
          command will allow us the same  facilities as  the C command,
          but with the command arguments specified as a decimal number.
          For example, enter the command:-

          H 16706

          DEBUG will display:-

               4142 16706 AB 0100 0001 0100 0010

          showing that the  hex  equivalent  of  decimal  16706  is the
          number 4142,  and displaying the ASCII and binary equivalents
          as before.  Similarly, by using  two decimal  arguments their
          hexadecimal sum and difference can be obtained.

               Now enter the command:-

               P

          DEBUG will respond:-

               D/S/U/V re-directed to printer.

          If you  have a  printer connected,  then the Display, Search,
          Unassemble, and Verify command output will now be  printed as
          a permanent  record.   This can make "reverse engineering" of
          code much easier.  Bear in mind however that since DEBUG uses
          the ROM routines to print, if the printer is not connected or
          busy, then DEBUG will simply wait.  To clear this problem you
          will need  to press  the RESET  button.  To restore output to
          the screen, enter the command:-

               P

          and DEBUG will respond:-



                                         Page - 25





                                 DEBUG TUTORIAL

               D/S/U/V re-directed to screen.

               On many occasions it is necessary  to locate  a sequence
          of  bytes  in  memory.    This can be performed by the Search
          command.  Enter the command:-

               S 0 7FFF 'TRS-80'

          DEBUG will respond:-

               7FA4

          Note that  there will  be a  delay of  about 4  seconds or so
          before the  command prompt returns, this is because DEBUG has
          been instructed  to  search  the  entire  ROM  for  this text
          string.

               The only  place in  the ROM where the string 'TRS-80' is
          found is at address 7FA4.  As we have seen, this is where the
          copyright message  displayed in BASIC is located.  The search
          command will also  find  multiple  occurrences  of  a string.
          Enter the command:-

               S 0 7FFF 'MENU'

          DEBUG will display:-

               5CFB
               519D
               0003

          indicating  that  the  string  'MENU'  is  found  at  these 3
          locations in the  ROM.    Try  another  example.    Enter the
          command:-

               S 0 7FFF 'Ok'

          DEBUG responds:-

               03F6

          This, of course, is the place in the ROM where the BASIC 'Ok'
          prompt is located, but where  is  it  referenced?    In other
          words, where  in the ROM do we refer to this address in order
          to print this message?  Address references are  stored in HI-
          LO byte  order, so we must search for the bytes F6 03.  Enter
          the command:-

               S 0 7FFF F6 3


                                         Page - 26





                                 DEBUG TUTORIAL

          DEBUG will respond:-

               050C

          Thus, at address 050C the pattern F6 03 was located.  This is
          likely to  be the immediate data of an extended register load
          command, so let us use the Unassemble command to see  if this
          is so.   The  op-code byte would be located one byte ahead of
          its immediate data, so  we  must  start  the  dis-assembly at
          address 050B.  Enter the command:-

               U 50B

          You should obtain the display:-

               050B 21 F6 03 LXI  H,$03F6

          This shows that at address 050B there is the HEX op-code byte
          21, which is indeed the  op-code  for  an  extended immediate
          load command.   The  instruction requires  3 bytes of memory,
          and the immediate data corresponds to the address  03F6.  The
          unassemble command  will attempt  to reconstruct the original
          assembly language instruction which in this case seems  to be
          the command  to load  the HL register pair with the immediate
          data 03F6.  Press the UP  ARROW key,  and you  should display
          the line:-

               050E CD B1 27 CALL $27B1

          In other words, it would appear that at address 27B1 there is
          a routine that would print  the  message  pointed  to  by the
          contents of  the HL register pair.  Perhaps we could make use
          of this routine.  Let us display the full message, and see if
          we can  determine the message structure.  Press the ENTER key
          to terminate the unassemble command, then enter the command:-

               D 3F6 3F8

          and observe the display:-

               03F6 4F 6B 0D 0A 00 42 72 65 Ok   Bre

          Notice  that  the  message  'Ok'  is  followed  by  the CR/LF
          sequence, and then a NULL byte.   Then  follows the  start of
          the  'Break'  message.    So,  we  have  determined that text
          messages in  the ROM  consist of  the text,  followed, in all
          probability,  by  the  CR/LF  sequence, and terminated with a
          NULL byte.  It would seem  that  in  order  to  print  a text
          message all  we need  to do  is load the HL register with the
          start address of the  message and  call the  routine at 27B1.

                                         Page - 27





                                 DEBUG TUTORIAL

          With this  knowledge, let  us now  use DEBUG to write a small
          assembly language program to demonstrate this concept.

               In this program we shall load  the HL  register with the
          address  of  the  copyright  message (7FA4) and then call the
          routine at 27B1 to print it.   Finally  we must  use a RETurn
          instruction to allow DEBUG to recover control.

               Enter the command:-

               A C000

          Notice that  you have  lost the '?' prompt.  DEBUG is waiting
          for you to enter assembly language  statements, or  the ENTER
          key to terminate the command.

               Enter the following:-

               LXI  H,$7FA4
               CALL $27B1
               RET

          Press the ENTER key to terminate the assembly.

          Now  use  the  Go  command  to  execute this code.  Enter the
          command:-

               G C000

          You should see the following display:-

               TRS-80 Model 100 Software
               Copr. 1983 Microsoft
                PC   AF   BC   DE   HL   SP
               0000 0A55 7FD5 00A3 FB6E E2B9

          Now let us assemble a program to do the same  job, but  to do
          so a  character at a time.  It turns out that the ROM routine
          invoked by RST 4  actually  prints  the  character  in  the A
          register.   We shall  use this  fact to write a small program
          that loads the HL register with the start address of  the ROM
          message, gets  a character, compares it with a NULL to see if
          we  have  reached  the  end,  if  not  print  the  character,
          increment the pointer and do it again.  Enter the command:-

               A C000

          and then the following lines of code:-



                                         Page - 28





                                 DEBUG TUTORIAL

               LXI H,$7FA4    ;Point to start of message
               MOV A,M        ;Get character
               CPI $0         ;Is it a NULL?
               RZ             ;If so, we are done
               RST 4          ;Not a NULL, so print the character
               INX H          ;Point to next character
               JMP $C003      ;and do it again

               Do  not  enter  the  comments,  they  are  only for your
          information.  Do not forget to terminate the  assembly with a
          blank line!   Now  use the  unassemble command to verify that
          you have indeed entered the correct code.   (Obviously, since
          the assemble  command invokes  the unassembler to display the
          result, this  has already  happened, but  just to familiarise
          yourself, try  the command U C000 C009)  Assuming you did not
          make any errors, invoke the Go command to  try the  code out.
          Enter the command:-

               G C000

          You should have obtained:-

               TRS-80 Model 100 Software
               Copr. 1983 Microsoft
                PC   AF   BC   DE   HL   SP
               0000 0054 7FD5 00A3 7FD5 E2B9

          Now let  us try  using a break point to see what happens.  We
          shall set a break point at address C009,  where we  loop back
          to get another character.  Enter the command:-

               B C009

          whereupon you will obtain the message:-

               Breakpoint set

          If you unassemble address C009 you will see:-

               C009 C3 76 E3 JMP  $E376

          this  is  because  the  breakpoint  replaces the code at this
          address with an unconditional jump into  the DEBUG breakpoint
          handler.  Now execute the command:-

               G C000





                                         Page - 29





                                 DEBUG TUTORIAL

          you should have obtained the display:-

               TBreakpoint reached
               Breakpoint cleared
               C009 C3 03 C0 JMP  $C003
                PC   AF   BC   DE   HL   SP
               C009 5410 7FD5 00A3 7FA5 E2B7

          Pause for  a moment and digest the information.  Notice first
          that the breakpoint handler has restored the code that was at
          address C009.   Also note the presence of the 'T' in front of
          the  first  Breakpoint  ....   message.     Remember  we  are
          displaying the  copyright message,  and thus the first letter
          would have been displayed, the 'T'  of 'TRS-80  ....'  Notice
          that the  A register  contains 54, this is the ASCII HEX code
          for  the  letter  'T'.    Notice  that  the  HL  register was
          originally loaded  with the  value 7FA4 but now contains 7FA5
          as a result of the INX  H instruction.   Finally  notice that
          the  stack  point,  SP,  now  contains E2B7 rather than E2B9.
          This is because we entered the code via a CALL instruction in
          the Go  command, and  thus the  return address  for DEBUG was
          placed on the stack.  This would automatically  decrement the
          stack pointer.

               To see  all of these things as they occur, let us single
          step the code by  means of  the Walk  instruction.   We shall
          reset all  the registers  to zero,  and then commence to walk
          the code at address C000.  Enter the commands:-

               R 0 0 0 0:W C000

          the display should show:-

                PC   AF   BC   DE   HL   SP
               C009 0000 0000 0000 0000 E2B7
               C000 21 A4 7F LXI  H,$7FA4
                PC   AF   BC   DE   HL   SP
               C009 0000 0000 0000 0000 E2B9

          The first line  shows  you  that  the  'R'  command correctly
          changed the register contents, the second line shows what the
          instruction is at  address  C000,  and  the  current register
          contents.   The walk command is now waiting for you to either
          execute the current  instruction  or  abort  by  pressing the
          ENTER  key.     Press   the  UP  ARROW  key  to  execute  the
          instruction.  The new display should be:-

               C003 7E       MOV  A,M
                PC   AF   BC   DE   HL   SP
               C003 0000 0000 0000 7FA4 E2B9

                                         Page - 30





                                 DEBUG TUTORIAL

          This shows that the next instruction is MOV A,M and  that the
          result of having executed the previous instruction is to have
          placed in the HL register the value 7FA4.   Now  press the UP
          ARROW again,  and observe that the letter 'T' is fetched from
          memory and placed into  the A  register, recall  that the HEX
          equivalent is 54.  You should have the display:-

               C004 FE 00    CPI  $00
                PC   AF   BC   DE   HL   SP
               C004 5400 0000 0000 7FA4 E2B9

          The  next  instruction  will  compare  the  contents of the A
          register with NULL.  Press the UP ARROW to execute and obtain
          the display:-

               C006 C8       RZ
                PC   AF   BC   DE   HL   SP
               C006 5410 0000 0000 7FA4 E2B9

          To display  what flags  have been set, press the ENTER key to
          terminate the walk, and enter the command:-

               X

          to obtain the eXpanded flags display:-

               SZdA PvC
               00010000

          This shows that as a result  of the  comparison process, only
          the Auxiliary Carry flag was set.  The Zero flag was not set,
          which indicates that the contents of  the accumulator  is not
          zero.

          Now re-enter the walk mode with the command:-

               W C006

          and obtain the display:-

               C006 C8       RZ
                PC   AF   BC   DE   HL   SP
               C006 5410 0000 0000 7FA4 E2B9

          Press  the  UP  ARROW  key,  and observe that the conditional
          return instruction is NOT taken.  The display will be:-





                                         Page - 31





                                 DEBUG TUTORIAL

               C007 E7       RST  4
                PC   AF   BC   DE   HL   SP
               C007 5410 0000 0000 7FA4 E2B9

          It would be rather tedious to have to single step all through
          the print  routine in  ROM, so  DEBUG gives you the option of
          executing just the sub-routine at full speed.   Press the 'X'
          key and obtain the display:-

               TC008 23       INX  H
                PC   AF   BC   DE   HL   SP
               C008 5410 0000 0000 7FA4 E2B9

          Notice that  the 'T'  has been  printed, displacing the DEBUG
          display.  By pressing the UP  ARROW key  you can  examine the
          effects of  the remainder of the instructions.  Take care not
          to single step the final return to DEBUG.   Whilst  this will
          not  cause  any  harm,  it  will  not do anything very useful
          either.

               Also take  care that  when actually  single stepping the
          ROM routines  to avoid  using the  'G' sub-command, except at
          known ROM routine entry points.  It is very dangerous to 'Go'
          into the middle of a ROM routine, and in general, the results
          are unpredictable.  The  Go  command  is  really  intended to
          execute code  by calling  it at a predictable and known entry
          point.  However, feel free to experiment, at  worst executing
          an unknown section of code will simply cause a cold start.

               This concludes  the tutorial section of DEBUG.  You have
          now seen  all of  the commands  at work,  and, hopefully, you
          will be  able to use the tool to its fullest extent with only
          a little more practice.

               For advice on the  use of  some of  the more  useful ROM
          routines, examine  the ROM Routines section of this book, and
          try unassembling and single  stepping these  routines to gain
          an  insight  into  their  operation.   Start with some of the
          simpler routines such as  GETUPR at  address 0FE8  and see if
          you can puzzle out how they perform their tasks.











                                         Page - 32





                             MODEL 100 ROM FUNCTIONS

          DISCLAIMER

               This  information  has  been  compiled from a variety of
          sources, including my own observations of the Model  100 ROM.
          Neither  MICROSOFT  nor  TANDY  sanction  the  use of the ROM
          routines, nor  guarantee that  they will  be the  same in all
          machines.   Since the  ROM contents  are copyright, it is not
          possible to  provide  complete  information  on  the routines
          without risk of infringement, therefore only the bare details
          are provided here.

               It  is   to  be   understood  that   in  providing  this
          information the  user assumes  all responsibility for any and
          all use that he or she may make of it, and in  particular the
          author  will  not  under  any circumstances be liable for any
          loss or damage however caused.   In other  words, YOU  ARE ON
          YOUR OWN, ALL BETS ARE OFF, YOU HAVE BEEN WARNED!

          ADDRESS                           COMMENT

          0000        RST 0
          0003        'Menu'
          0008        RST 1   Tests  for  special  chars and falls into
                              RST 2
          0010        RST 2   Skips  spaces,  puts   address   of  next
                              meaningful char in HL and char in A.
          0018        RST 3   Compares [HL] & [DE] and returns flags.
          0020 prtchr RST 4   Displays the ASCII contents of [A] at the
                              current cursor location.
          0024 trap           Power Down routine. Vectors  through F602
                              to 1431  where actual power down sequence
                              occurs.
          0028        RST 5   JMP 1069 Checks variable type.
          002C        RST 5.5 Hardware Interrupt
          0030        RST 6   JMP 33DC Returns the sign of FAC1
          0038        RST 7   Jumps to 7FD6  where  the  byte following
                              the RST  7 op-code  is used  as an offset
                              into the branch table starting at FADA.
          003C        RST 7.5 Adjust power down  values,  updates time,
                              checks  keyboard  for  keys pressed. This
                              routine can be intercepted by redirecting
                              the RET located F5FF.
          0040                BASIC Function Address
          0080                BASIC Keyword List. Bit 7 is set in first
                              character of each keyword.
          0262                BASIC Command Table address
          02EE                Table of BASIC addresses
          031C                BASIC Error Codes. 2 bytes for each code.
          035A                This area contains the initial values for
                              the reserved RAM Area from F5F0 to F67F

                                         Page - 33





          ADDRESS                           COMMENT

          03C5                'M7I1E'
          03EA                ' Error'
          03F1                ' in '
          03F6                'Ok'
          03FB                'Break'
          04DD                Prints BASIC  error message. [A] contains
                              error code. (28 - 58)
          0726                FOR
          076B                TO
          0840                BASIC  command  despatcher.  [A] contains
                              token.
          0858                Sets pointer to BASIC text
          0872                DEF
          0881                DEFDBL
          0886                DEFINT
          0896                DEFSNG
          089F                DEFSTR
          08DB                FC error
          08EB mklnum         Converts  ASCII  string of decimal digits
                              pointed to by [HL] into 2 byte integer in
                              [DE]. NB. This is not completely general.
                              The  maximum  decimal  number  is  65529,
                              corresponding to  the largest line number
                              in BASIC.  Any  number  larger  than this
                              will return 1999 in [DE]
          090F                RUN
          091E                GOSUB
          0936                GOTO
          094D                UL line error jumps here.
          0966                RETURN
          099E                DATA
          09A0                REM, ELSE
          09C3                LET
          0A2F                ON
          0A34                ON ERROR
          0AB0                RESUME
          0B0F                ERROR
          0B1A                IF
          0B4E                LPRINT
          0B56                PRINT
          0C01                TAB(
          0C45                LINE
          0C50                LINE INPUT
          0C74                '?Redo from start',CR,LF
          0C99                INPUT #
          0CA3                INPUT
          0CD9                READ
          0D71                '?Extra ignored',CR,LF
          0F56                ERL
          0F7E                VARPTR

                                         Page - 34





          ADDRESS                           COMMENT

          0FE8 getuc          Get char pointed to by [HL] and fall into
                              TOUPER.
          0FE9 touper         Convert char in [A] to upper case.
          108C                OR
          1097                AND
          10A2                XOR
          10AD                EQV
          10B5                IMP
          10C8                LPOS
          10CE                POS
          1100                INP
          110C                OUT
          112E                Convert ASCII text to integer.
          113B                LLIST
          1140                LIST
          11A2 prtstr         Print chars pointed to by [HL]  until NUL
                              byte is found. (Same as routine at 5A58)
          11AA putbuf         Puts  characters  into  buffer  until NUL
                              byte is found.
          1284                PEEK
          128B                POKE
          1297 atoint         Convert  string  pointed  to  by  [HL] to
                              integer. Errors  into BASIC error routine
                              if out of range.
          12CB getchr         Get chars  from  keyboard.  Routine waits
                              until a  char is  entered and returns the
                              char in [A]. No other registers affected.
          12F0                PASTE
          13A5                Toggle the label line.
          13DB chkque         Checks the keyboard queue for characters.
                              Z flag  is set  if no  chars found, reset
                              otherwise.
          1412                Break routine.
          1419                POWER
          1431                Power OFF routine. Returns  to program on
                              power up.
          1451                POWER OFF
          1459                POWER CONT
          1469                Set power down values.
          1470 pnotab         Prints  char  in  [A]  without  expanding
                              tabs. C set on  exit if  cancelled by BRK
                              otherwise reset.
          14A8 mtron          Turn cassette motor ON
          14AA mtroff         Turn cassette motor OFF
          14B0 casin          Read  a  char  from  cassette  and update
                              checksum.  On  entry,   [C]   is  current
                              checksum. On exit [A] contains character,
                              [C] is updated checksum.



                                         Page - 35





          ADDRESS                           COMMENT

          14C1 casout         Write  a  char  to  cassette  and  update
                              checksum.   On    entry,   [A]   contains
                              character,    [C]    contains    previous
                              checksum.  On  exit, [C] contains updated
                              checksum.
          17E6 setser         Set    serial     parameters.    Activate
                              RS232/Modem.  On  entry,  [HL]  points to
                              ASCII parameter  string  terminated  in a
                              NUL  byte,  using  same  syntax as TELCOM
                              STAT command. On exit, C flag  is set for
                              RS232, reset for Modem.
          1889                EOF
          1904                TIME$
          190F rdtime         Read system time. On entry [HL] points to
                              8 byte buffer  to  receive  the  time. On
                              exit [HL]  left pointing to end of buffer
                              with time as hh:mm:ss in ASCII
          1924                DATE$
          192F rddate         Read system date. On entry [HL] points to
                              8 byte  buffer to  receive date. On exit,
                              [HL] points to end of buffer with date in
                              the form mm/dd/yy in ASCII.
          1955                DAY$
          1962 rdday          Read system  day. On entry [HL] points to
                              3 byte buffer  to  receive  day.  On exit
                              [HL] points  to end of buffer with day in
                              3 letter ASCII format.
          1978                'SunMonTueWedThuFriSat'
          1999                Convert byte pointed to by [DE] to ASCII.
                              [M] holds the result.
          19AB                TIME$ command
          19BD                DATE$ command
          19F1                DAY$ command
          1993                MAXRAM
          1A78                IPL
          1A9E                COM, MDM
          1AC3                KEY ON/OFF/STOP
          1B0F                ON TIME$
          1BB8                KEY
          1BBD                KEY LIST
          1BE0 prtasc         Prints printable characters pointed to by
                              [HL] for length in  [B].   If ASCII value
                              of char  is less than $20 or greater than
                              $7F, a blank is displayed.
          1C0E                Defines function keys.
          1C39                PSET
          1C66                PRESET
          1C6D drwlin         Line drawing routine.
          1D5F                Subroutine for PRINT@
          1D90                CSRLIN

                                         Page - 36





          ADDRESS                           COMMENT

          1D9B                MAX
          1DB2                MAXFILES
          1DB9                HIMEM
          1DC3                WIDTH
          1DC5                SOUND
          1DE5                SOUND OFF
          1DEC                MOTOR
          1DF3                Turn motor ON
          1DF5                Turn motor OFF
          1DFA                CALL
          1E22                SCREEN
          1E5E prtlcd         LCOPY Dumps screen  to  printer. Graphics
                              are ignored.
          1F3A                FILES
          1F91                KILL
          1FBE kilasc         Kill a  text file. [DE] contains the file
                              top  start  address,  [HL]  contains  the
                              address of entry flag.
          2037                NAME
          20FE                NEW
          220F maktxt         Create a  text (.DO) file. On entry, file
                              name  must  be  stored  at  FC93,  no .DO
                              extension required. On exit [HL] contains
                              top address of  new  file,  [DE] contains
                              address of  directory entry  flag. C flag
                              is set if file  already exists,  reset if
                              it is a new file.
          2280                CSAVE
          2298                CSAVE's current BASIC program
          22B9                Send  the  number  of  bytes in [DE] from
                              memory  location  contained  in  [HL]  to
                              cassette.
          22CC                SAVEM
          22DD                CSAVEM
          2377                CLOAD
          2413                Gets  the  number  of  bytes in [DE] from
                              tape,  and   stores   them   starting  at
                              location pointed to by [HL].
          2456                CLOAD?
          2481                'Verify failed',CR,LF
          2491                LOADM,RUNM
          24A7                CLOADM
          2542                Move  [B]  bytes  from  address  [HL]  to
                              address [DE] from LO to HI
          2573                CLOADM?
          25D5                'Top: '
          25DB                'End: '
          25E1                'Exe: '
          26FE                'Found:'
          2705                'Skip:'

                                         Page - 37





          ADDRESS                           COMMENT

          273A                STR$
          27B1                Display a string of characters pointed to
                              by [HL] until NUL byte found.
          28CC                String addition
          290C                Move [L] bytes from an address in [BC] to
                              an address in [DE] from LO to HI.
          2943                LEN
          294F                ASC
          2965                CHR$
          296D                STRING$
          298E                SPACE$
          29AB                LEFT$
          29DC                RIGHT$
          29E6                MID$
          2A07                VAL
          2A37                INSTR
          2B4C                FRE
          2B69                Put FAC1 - FAC2 into FAC1
          2B78                Put FAC1 + FAC2 into FAC1
          2CFF                Put FAC1 * FAC2 into FAC1
          2DC7                Put FAC1 / FAC2 into FAC1
          2EE6                Move  [C]  bytes  from  address  [HL]  to
                              address [DE] from LO to HI.
          2EEF                COS
          2F09                SIN
          2F58                TAN
          2F7A                ATN
          2FCF                LOG
          305A                SQR
          30A4                EXP
          313E                RND
          318E                Move FAC1 to FC79 - FC80
          3194                Add FAC1 to memory
          319A                Subtract memory from FAC1
          31A0                Put FAC1 * FAC1 into FAC1
          31A3                Multiply memory and FAC1
          31B5                Move FAC1 to FAC2
          31B8                Move FP number pointed to by [HL] to FAC1
          31CA                Move [FAC1] to memory pointed to by [HL]
          3234                Save FAC1 to stack
          325C                Floating point constants
          33FD                Negate FAC1
          3407                SGN
          3469 mvup           Move  [B]  bytes  from  address  [DE]  to
                              address [HL] from LO to HI.
          3472 mvdn           Move  [B]  bytes  from  address  [DE]  to
                              address [HL] from HI to LO.
          3501                CINT
          352A                CSNG
          35BA                CDBL

                                         Page - 38





          ADDRESS                           COMMENT

          3645                FIX
          3654                INT
          39D4 prtint         Print the  16 bit  integer in [HL] at the
                              current cursor location.
          3FA0                TIME$ ON
          3FB9                TIME$ STOP
          407F                RESTORE
          409A                STOP
          409F                END
          40DA                CONT
          40F1 chkupr         Determine if [HL] points  to U/C  char. C
                              flag set if not.
          40F2 chkapr         Determine  if  [A]  contains  U/C char. C
                              flag set if not.
          40F9                CLEAR
          4174                NEXT
          4222 newln          Print CR/LF
          4229 beep           BEEP
          422D home           Home cursor
          4231 cls            Clear screen and home cursor.
          4235 lockln         Lock line 8
          423A unlock         Unlock line 8
          423F inscrl         Inhibit scroll
          4244 enscrl         Enable scroll
          4249 curon          Turn cursor ON
          424E curoff         Turn cursor OFF
          4253 delin          Delete current line
          4258 inslin         Insert blank line
          425D clreol         Clear to end of line
          4269 revon          Turn ON reverse video
          426E revoff         Turn OFF reverse video
          4270 prtesc         Print CHR$(27) then character in [A]
          427C getcur         Get current cursor position.  On exit [H]
                              contains  column,  (1  - 40) [L] contains
                              row, (1 - 8).
          428A erafnk         Erase function key display
          42A5 stdspf         Set & Display function keys
          42A8 dspfnk         Display function keys
          42BA clrlbl         Clear label line
          42A5 setfnc         Set function  key  defs.  On  entry, [HL]
                              points to function key definition table.
          42AB dsplbl         Display function key defs on label line.
          463E getln          Display a  ? prompt  and fall  into get a
                              line from keyboard routine.
          4644 getlnp         Get line, no prompt
          478B                DIM
          4790                Get variable and type
          4991                USING
          4B44 prtchr         Print the char in  [A] at  current cursor
                              location.

                                         Page - 39





          ADDRESS                           COMMENT

          4B55 prttab         Print  char  in  [A]  expanding  tabs  to
                              spaces. C set  on  exit  if  cancelled by
                              BRK, else reset.
          4B7A                Send char in [A] to printer
          4BA0                Send CR to printer
          4BEA                INKEY$
          4CCB                OPEN
          4D70                LOAD
          4D71                MERGE
          4DCF                SAVE
          4E28                CLOSE
          4E8E                INPUT$
          4F0A nulfil         Fill  [B]  bytes  with  NUL  starting  at
                              address in [HL]
          4F0B chrfil         Fill [B] bytes with char in  [A] starting
                              at address in [HL]
          506F                LFILES
          5071                DSKO$
          5073                DSKI$
          50F1                'LCD'
          50F5                'CRT'
          50F9                'CAS'
          50FD                'COM'
          5101                'WAND'
          5106                'LPT'
          5110                'MDM'
          510E                'RAM'
          5146 telcom         TELCOM entry address
          517C                'Telcom: '
          5185                'STAT'
          518B                'TERM'
          5191                'CALL'
          5197                'FIND'
          519D                'MENU'
          51A4                Telcom function key defs. (set 1)
          51E7                '0 pps'
          5244                'Calling'
          52BB disc           'Disconnect   phone   line.  No  explicit
                              entry/exit conditions.
          52D0 connct         Connect   phone    line.    No   explicit
                              entry/exit conditions.
          532D dial           Dial phone  number. On entry, [HL] points
                              to ASCII string of number.
          5583                'FullHalfEcho'
          5594                ' Wait '
          5751                'File to upload'
          5791                Display string  pointed to  by [HL] until
                              NUL byte  is found.  If cursor  is not at
                              start  of  line,  a   CR/LF  sequence  is
                              printed before displaying the string.

                                         Page - 40





          ADDRESS                           COMMENT

          5760                'File to download'
          5771                ' aborted',CR,LF
          5786                'Disconnect'
          5797 menu           Menu entry point.
          582E fremem         Prints number of free bytes.
          5834                Prints 'Select:' and responds to input
          5970 lfiles         Lists files on screen
          5A58 prtstr         Prints string of chars pointed to by [HL]
                              until NUL byte is found. (Same as 11A2)
          5A79 clrfnc         Fills function key defs with blanks.
          5A7C setfnc         Load function key  defs.  [HL]  points to
                              function  definitions,  last character of
                              each must have bit 7 set. Use 128 to skip
                              a keydef.
          5A9E dspftb         Display function key table if enabled.
          5AA9 filsch         Search for  file in  directory.  On entry
                              [DE] points to file name to  find, (ASCII
                              filename +  NUL byte) [A] contains length
                              of  filename.    On  exit,  [HL] contains
                              start address  of file directory entry, Z
                              set if not found, reset otherwise.
          5AE3 gtstrt         Get start address of file. On entry, [HL]
                              points to  address of directory entry for
                              the file.  On  exit  [HL]  points  to RAM
                              start address of file.
          5AE9 'JanFebMarAprMayJunJlyAugSepOctNovDec(C)Microsoft'
          5B1A                '-.-'
          5B24                'Select:         ' (9 spaces)
          5B3F                Blank set of function key definitions
          5B4B                Cold start definitions for BASIC function
                              keys. Bit 7 set of last character.
          5B68                ADDRSS entry address
          5B6F                SCHEDL entry address
          5B9A                Prints '  not  found',CR,LF  'Press space
                              bar for MENU' and responds appropriately.
          5CCE                'ADRS.DO'
          5CD6                ' not found'
          5CE1                'Adrs: '
          5CE8                'Schd: '
          5CEF                'FIND'
          5CF5                'LFND'
          5CFB                'MENU'
          5D02                'NOTE.DO'
          5D0A                Set 1 ADDRSS/SCHDL function key defs
          5D1E                Set 2 ADDRSS/SCHDL function key defs
          5D46 chkchr         Check char pointed to by [HL]. If it is a
                              space INX HL and RET with Z set. If not a
                              space  leave  [HL]  alone  and RET with Z
                              clear.
          5D6A                Home cursor. [A] and [HL] destroyed.

                                         Page - 41





          ADDRESS                           COMMENT

          5D70                Print time and date at top  of screen and
                              update until a key is pressed.
          5DEE text           TEXT entry point
          5DF3                Request   file   to   edit   and  respond
                              appropriately.
          5E15                'File to edit'
          5E2A                Function key defs for TEXT
          5E51                EDIT
          5F2F pause          Wait for  space  bar  to  be  pressed and
                              return.
          5F38                'Text ill-formed',BEEP
          5F49                CR,LF,'Press space bar for '
          5F60                'TEXT'
          60B1                'Memory full',BEEP
          65C3                PUSH HL, moves memory starting at [HL] to
                              address in [DE] until NUL byte  is found,
                              then POP HL
          65CE                'No match'
          65D7                'String:'
          670C                'Width:'
          6735                'Save to:'
          67D4                'Load from:'
          6B61 inschr         Insert a character into a file. On entry,
                              [A] contains  character,  [HL]  points to
                              address to  insert. On exit, [HL]=[HL+1],
                              and C set if out of memory.
          6B6D makspc         Insert a specified number  of spaces into
                              a file.  On entry [BC] contains number of
                              spaces to insert, [HL]  points to address
                              at which to insert. On exit [HL] and [BC]
                              are preserved. C set if out of memory.
          6B9F delchr         Delete chars.  [BC] num  chars to delete,
                              [HL] address at which to start.
          6BDB movup          Move  [BC]  bytes  from  address  [HL] to
                              address [DE] from LO to HI.
          6BE6 movdn          Move  [BC]  bytes  from  address  [HL] to
                              address [DE] from HI to LO.
          6BF1                First 8  programs in directory, including
                              file types and entry addresses.
          6C49 basic          BASIC entry point.
          6C93 savfnc         Save function key defs temporarily.
          6C9C resfnc         Restore function key defs.
          6CD6 coldst         Cold start reset.
          6CE0 warmst         Warm start reset.
          6D3F printr         Send a char  to  printer.  On  entry, [A]
                              contains char, on exit C set if cancelled
                              by BRK, else reset.
          6D6D rxqchk         Check RS-232 queue for chars. On exit [A]
                              contains number  of chars  pending. Z set
                              if none pending, else reset.

                                         Page - 42





          ADDRESS                           COMMENT

          6D7E gtschr         Get a char from RS-232 queue. On exit [A]
                              contains char received. Z flag set if OK,
                              else  reset  if  error.  C  set   if  BRK
                              pressed, else reset.
          6E0B txon           Send XON resume character. (CTRL-Q)
          6E1E txoff          Send XOF pause character. (CTRL-S)
          6E32 txchr          Send char in [A] to RS-232 or modem (with
                              XON/XOF).  Exit conditions unknown.
          6E3A sdchr          Send char in [C]  to MODEM/RS-232 without
                              XON/XOFF control
          6E75 setbd          Set  baud  rate  for RS-232. On entry [H]
                              contains baud rate in range 1 - 9 or M.
          6EA6 intcom         Initialise RS-232 and modem. On entry [H]
                              contains baud  rate in  range 1 - 9 or M,
                              [L] contains UART  configuration  code. C
                              set if RS-232, reset for Modem.
                              Bit 0 = number of stop bits 0=1, 1=2
                              Bit 1 = parity setting 1 = odd, 0 = even
                              Bit 2 = parity. 1 = disable, 0 = enable
                              Bit 3/4 word length. 01=6 10=7, 11=8
                              The  byte  in  [L]  is  ANDed with $1F to
                              ignore  bits  5  -  7.  The  text  string
                              containing  the  current  STAT setting is
                              located  at  F65B   (5   bytes)   in  the
                              sequence:-  baud,length,parity,stop bits,
                              XON/XOFF switch.
          6ECB clrcom         De-activates RS-232/Modem.
          6EEF cardet         Detect  carrier.  (Modem  only)  On exit,
                              [A]=0 if  carrier, and  Z flag  is set if
                              carrier, else reset.
          6F46 syncw          Write cassette header and sync byte only.
          6F5B dataw          Write  a   character   to   cassette,  no
                              checksum.
          6F85 syncr          Read cassette header and sync byte only.
          702A rdcass         Read   a   character  from  cassette  (no
                              checksum) On exit [D]= character.
          714E                Add a character to keyboard buffer.
          7242                Scans keyboard for character and returns.
                              Z flag  is set if no key found, otherwise
                              reset. C  flag set  if special character,
                              reset if normal character. Special chars:
                              [A]=0 F1, [A]=1 F2,  [A]=2 F3,  [A]=3 F4,
                              [A]=4 F5,  [A]=5 F6,  [A]=6 F7, [A]=7 F8,
                              [A]=8 LABEL, [A]=9  PRINT,  [A]=10 SHIFT-
                              PRINT, [A]=11 PASTE
          7270 keyx           Check  keyboard  queue  for characters or
                              BRK. On exit, Z flag is  set if  queue is
                              empty, reset if keys pending. C is set if
                              BRK, reset for any other key.


                                         Page - 43





          ADDRESS                           COMMENT

          7283 brkchk         Check for BRK characters only. (CTRL-C or
                              CTRL-S).  On  exit,  C  is  set if BRK or
                              PAUSE, reset for any other key.
          72C5 music          Sound routine.  On  entry,  [DE] contains
                              pitch value,[B] contains duration.
          7440 setcur         Position cursor,  [D]=col (1-40), [E]=row
                              (1-8)
          744C plot           Turn pixel  ON. [D]  contains x position,
                              [E] contains y position.
          744D unplot         Turn pixel  OFF. [D] contains x position,
                              [E] contains y position.
          7662                Same as BEEP
          7676                Pulse buzzer
          770F                Character   set,   5   bytes   each   for
                              characters from 32 - 127
          78F1                Character   set,   6   bytes   each,  for
                              characters from 128 - 255
          7BF1                Keyboard matrix
          7D33                Initialisation process
          7DE7                Initialise pointers
          7EAC                Prints number of free bytes.
          7F98                ' Bytes free'
          7FA4                'TRS-80 Model  100 Software',CR,LF,'Copr.
                              1983 Microsoft',CR,LF,NULL



























                                         Page - 44





                             MODEL 100 RESERVED RAM

          DISCLAIMER

               This  information  has  been  compiled from a variety of
          sources, including my own observations of the Model  100 RAM.
          Neither  MICROSOFT  nor  TANDY  sanction  the  use  of  these
          locations, nor guarantee that  they will  be the  same in all
          machines.  It is not possible to provide complete information
          on these locations, thus only the  bare details  are provided
          here.

               It  is   to  be   understood  that   in  providing  this
          information the user assumes  all responsibility  for any and
          all use  that he or she may make of it, and in particular the
          author will not under any  circumstances  be  liable  for any
          loss or  damage however  caused.   In other words, YOU ARE ON
          YOUR OWN, ALL BETS ARE OFF, YOU HAVE BEEN WARNED!

          ADDRESS                      COMMENT

          F5F4+   HIMEM value
          F5F6    Code called at 7D91 and &CD5
          F5F9    RST 5.5 vector
          F5FC    RST 6.5 vector
          F5FF    RST 7.5 vector
          F602    JMP 1431
          F605    Code CALLed at 7DC6 and 7E24 which checks for the
                  existence of an option ROM on power up.
          F60F    Code called 0830
          F624    Code called when choosing an option ROM from menu.
          F67E    Code
          F630    8 bytes used as KEY ON/OFF flags. ON=1 OFF=0
          F639    Vertical print position, (0-7)
          F63A    Horizontal print position, (0-39)
          F63B    Number of active lines. (0-8)
          F63C    Number of active columns. (0-40)
          F63D    Label line flag. 0 = unused  1 = used
          F648    Reverse video flag. 0 = normal.  Any other values,
                  reverse
          F64E    X pixel set
          F64F    Y pixel set
          F657    Power down value
          F65A    Linefeed switch. 0 = no LF, non-zero = LF
          F65B    RS-232 parameter image
          F661    CALL + target address.
          F672    Error code
          F674    LPOS value
          F675    O/P flag. 0=screen, 1=printer
          F678+   Top of RAM value
          F67C+   Start address of BASIC program currently being
                  executed.

                                         Page - 45





          ADDRESS                      COMMENT

          F67A+   Line number of current line being executed, contains
                  FFFF if no program running.
          F680    Holds end of BASIC statement marker, either : or NUL
          F681    BASIC tokenized text
          F685    Input Buffer
          F788    POS value
          F789    Current active function key defs. 16 bytes each.
          F80A    Temporary storage for function key defs. 16 bytes
                  each.
          F88C+   Pointer to start of PASTE text.
          F897    Start of work area
          F929    Day of month low digit
          F92A    Day of month high digit
          F92B    Day of week. 0 = Sunday
          F92C    Month (1-12)
          F92D    Year, Low digit
          F92E    Year High digit
          F92F    Timer. Decreases from 125 to zero. When 0, time and
                  date from clock chip into system RAM.
          F930    Timer. Decreases from 12 to 1. When 1, byte at F931
                  decreased by 1.
          F931    Power Down counter. When 1, power goes OFF.
          F933    Holds current time, day, month. 10 bytes.
          F93D    Holds time for ON TIME$ command, 6 bytes
          F943    COM ON/OFF flag. ON = 1  OFF = 0
          F945+   Address of ON COM routine.
          F947    TIME$ ON/OFF flag
          F948+   Address of ON TIME$ routine.
          F94A    Key ON/OFF flags and addresses. 3 bytes for each of
                  the 8 function keys. Extends to F961
          F962    Start of RAM directory. 27 file slots, each 11 bytes
                  long. First byte of each entry determines file type.
                  Bit 7 = 1 valid entry
                  Bit 6 = 1 for ASCII text file
                  Bit 5 = 1 M/C file (.CO)
                  Bit 4 = 1 ROM file
                  Bit 3 = 1 for hidden files.
                  Bytes 2/3 are actual file addresses in LO-HI byte
                  order. The next 8 bytes are the actual filenames and
                  extensions.
          F962    BASIC file slot
          F96D    TEXT file slot
          F978    TELCOM file slot
          F979    ADDRSS file slot
          F98E    SCHEDL file slot
          F999    SUZUKI slot for BASIC file not yet saved in
                  directory.
          F9A4    HAYASHI slot used for PASTE buffer
          F9AF    RICKY slot used in BASIC EDIT mode
          F9BA    User file slots 1 - 19. Extends to FA8A

                                         Page - 46





          ADDRESS                      COMMENT

          FA8B    End of directory marker
          FAAD    0 = Label line disabled.  Non-zero = enabled
          FAAF    Name of IPL program. 11 bytes last 2 are CR/LF
          FAC9    Holds value used by RST 7 to compute offset into
                  table.
          FAD0+   Length of CLOADed/CSAVEd program
          FADA    Branch table used by RST 7. Extends to FB39
          FAE4+   Vector for LPRINT routine
          FB0C+   Vector for F6 key when in TELCOM TERM mode
          FB0E+   Vector for F7 key when in TELCOM TERM mode
          FB14+   Vector for WIDTH command in BASIC
          FB28+   Vector for LOC command in BASIC
          FB2A+   Vector for EOF command in BASIC
          FB2C+   Vector for LFILES command in BASIC
          FB30+   Vector for DSKO$ command in BASIC
          FB65    BASIC variable type. 2 = INT, 3 = STRING, 4 = SP, 8 =
                  DP
          FB94+   Line number of current DATA line being read.
          FB9B+   Start of current BASIC line
          FB9F+   Line number of last line where an error occurred.
          FBA1+   Line number of most recently entered/listed line
          FBA3+   Location of statement where error occurred
          FBA5+   Location of ON ERROR GOTO line
          FBA7    Error status flag
          FBA8+   End of BASIC expression
          FBAA+   Line where BRK occurred, or last line executed before
                  program end
          FBAC+   Address used by CONT
          FBAE+   Points to start of TEXT file storage in RAM
          FBB6+   Address of first unused byte in RAM
          FBB8+   Address of next DATA item to be read
          FC18    FAC1 - 8 bytes
          FC69    FAC2 - 8 bytes
          FC82    MAXFILES value
          FC93    Filename Buffer #1
          FC9C    Filename Buffer #2
          FD88    Date/Time in ASCII. Used for MENU routine. Extends to
                  FD9F
          FDD9    Filespec to be located by search routine at 5AA6.
                  Extends to FDE2
          FDF0    Holds filespec to be checked against that searched
                  for by routine at 5AA6, extends to FDF9
          FE00    Start of LCD image memory. 320 bytes extends to FF3F
          FF44    SOUND ON/OFF flag. ON = 0  OFF = 175
          FF45    Cassette ON/OFF flag
          FF90    Contains a 2 as long as a noncontrol key held down





                                         Page - 47





          ADDRESS                      COMMENT

          FF97    This byte holds different values depending on what
                  keys are being pressed.
                  Bit 0 = 1 spacebar
                  Bit 1 = 1 backspace
                  Bit 2 = 1 tab
                  Bit 3 = 1 ESC
                  Bit 4 = 1 PASTE
                  Bit 5 = 1 LABEL
                  Bit 6 = 1 PRINT
                  Bit 7 = 1 ENTER
          FF98    This byte holds different values depending on the key
                  currently being pressed.
                  Bit 0 = 1 F1
                  Bit 1 = 1 F2
                  Bit 2 = 1 F3
                  Bit 3 = 1 F4
                  Bit 4 = 1 F5
                  Bit 5 = 1 F6
                  Bit 6 = 1 F7
                  Bit 7 = 1 F8
          FFA2    This byte holds different values depending upon what
                  key is pressed.
                  Bit 0 = 1 SHIFT
                  Bit 1 = 1 CTRL
                  Bit 2 = 1 GRPH
                  Bit 3 = 1 CODE
                  Bit 4 = 1 NUM
                  Bit 5 = 1 CAPS LOCK
                  Bit 6     Unknown
                  Bit 7 = 1 PAUSE
          FFA6    Holds different values depending on last key pressed.
                  (Not ASCII)
          FFAA    Number of characters in keyboard buffer
          FFAB    Keyboard buffer. 64 bytes. Odd bytes contain ASCII
                  values, FF in an even bytes indicates a function key.
          FFEC    5 bytes that contain a bit image of the current
                  cursor location. These can be used in conjunction
                  with the current cursor location codes to dump the
                  screen, including graphics to the printer.

          Document Revision Date: 19 June 1990
          DEBUG Version 4.13 14 June 1990

          A.Ryan
          P.O. Box 222,
          Carp,
          Ontario,
          Canada.
          (613) 256-2487


                                         Page - 48
